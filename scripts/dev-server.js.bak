import { createServer } from 'vite';
import express from 'express';
import mongoose from 'mongoose';
import cors from 'cors';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import dotenv from 'dotenv';
import fs from 'fs';
import nodemailer from 'nodemailer';
import winston from 'winston';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const rootDir = join(__dirname, '..');

// Load environment variables
dotenv.config({ path: join(rootDir, '.env') });

// Check if we're in production mode
const isProduction = process.env.NODE_ENV === 'production';

// Configure Winston logger
const logger = winston.createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.File({ filename: 'error.log', level: 'error' }),
    new winston.transports.File({ filename: 'combined.log' }),
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      )
    })
  ]
});

// Create email transporter pool
const transporterPool = Array(5).fill(null).map(() => nodemailer.createTransport({
  pool: true,
  host: process.env.EMAIL_HOST,
  port: parseInt(process.env.EMAIL_PORT),
  secure: process.env.EMAIL_SECURE === 'true',
  auth: {
    user: process.env.EMAIL_USER,
    pass: process.env.EMAIL_PASS
  },
  maxConnections: 5,
  maxMessages: 100,
  rateLimit: 5 // 5 emails per second
}));

// Round-robin email transporter selection
let currentTransporterIndex = 0;
function getNextTransporter() {
  currentTransporterIndex = (currentTransporterIndex + 1) % transporterPool.length;
  return transporterPool[currentTransporterIndex];
}

// Verify email configuration for each transporter
transporterPool.forEach((transporter, index) => {
  transporter.verify((error, success) => {
    if (error) {
      logger.error('Email configuration error for transporter ' + index, error);
    } else {
      logger.info('Email transporter ' + index + ' is ready');
    }
  });
});

// Email sending function with retry logic and local storage
const failedEmailsPath = join(rootDir, 'failed-emails.json');
let failedEmails = [];

try {
  if (fs.existsSync(failedEmailsPath)) {
    failedEmails = JSON.parse(fs.readFileSync(failedEmailsPath, 'utf8'));
  }
} catch (error) {
  logger.error('Error loading failed emails:', error);
}

async function saveFailedEmail(emailData) {
  failedEmails.push({
    ...emailData,
    timestamp: new Date().toISOString(),
    retryCount: 0
  });
  try {
    fs.writeFileSync(failedEmailsPath, JSON.stringify(failedEmails, null, 2));
  } catch (error) {
    logger.error('Error saving failed email:', error);
  }
}

async function sendEmail(options, retries = 3) {
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      const transporter = getNextTransporter();
      const info = await transporter.sendMail({
        from: `"${process.env.EMAIL_FROM_NAME}" <${process.env.EMAIL_USER}>`,
        ...options
      });
      logger.info('Email sent successfully', {
        messageId: info.messageId,
        to: options.to,
        subject: options.subject
      });
      return true;
    } catch (error) {
      logger.error(`Email sending attempt ${attempt} failed:`, {
        error: error.message,
        to: options.to,
        subject: options.subject
      });
      
      if (attempt === retries) {
        await saveFailedEmail(options);
        throw error;
      }
      // Exponential backoff
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
    }
  }
  return false;
}

// Retry failed emails periodically
setInterval(async () => {
  if (failedEmails.length === 0) return;

  const email = failedEmails[0];
  if (email.retryCount >= 5) {
    logger.error('Email failed permanently after 5 retries', email);
    failedEmails.shift();
    return;
  }

  try {
    await sendEmail(email);
    failedEmails.shift();
    logger.info('Successfully sent previously failed email', {
      to: email.to,
      subject: email.subject
    });
  } catch (error) {
    email.retryCount++;
    logger.error('Failed to retry sending email', {
      error: error.message,
      to: email.to,
      subject: email.subject,
      retryCount: email.retryCount
    });
  }

  fs.writeFileSync(failedEmailsPath, JSON.stringify(failedEmails, null, 2));
}, 5 * 60 * 1000); // Retry every 5 minutes

async function startServer() {
  const app = express();
  const PORT = process.env.PORT || 5001;

  // Middleware
  app.use(cors({
    origin: ['http://localhost:5001', 'http://localhost:5173'],
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization']
  }));
  app.use(express.json());

  // Connect to MongoDB with retry logic
  const connectWithRetry = async (retries = 5) => {
    for (let attempt = 1; attempt <= retries; attempt++) {
      try {
        await mongoose.connect(process.env.MONGODB_URI);
        logger.info('Connected to MongoDB');
        return;
      } catch (error) {
        logger.error(`MongoDB connection attempt ${attempt} failed:`, error);
        if (attempt === retries) {
          throw error;
        }
        // Exponential backoff
        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
      }
    }
  };

  try {
    await connectWithRetry();
  } catch (err) {
    logger.error('Failed to connect to MongoDB after all retries:', err);
  }

  if (isProduction) {
    app.use(express.static(join(rootDir, 'dist')));
  } else {
    const vite = await createServer({
      root: rootDir,
      server: {
        middlewareMode: true,
        watch: {
          usePolling: true,
          interval: 100
        }
      },
      appType: 'spa'
    });
    app.use(vite.middlewares);
  }

  // API Routes
  app.post('/api/contact', async (req, res) => {
    try {
      const { name, email, phone, message } = req.body;
      
      if (!name || !email || !message) {
        return res.status(400).json({ 
          success: false, 
          message: 'Name, email and message are required' 
        });
      }

      logger.info('Processing contact form submission', { name, email });

      // Send email to admin
      await sendEmail({
        to: process.env.EMAIL_TO,
        subject: `New Contact Form Submission from ${name}`,
        html: `
          <h2>New Contact Form Submission</h2>
          <p><strong>Name:</strong> ${name}</p>
          <p><strong>Email:</strong> ${email}</p>
          <p><strong>Phone:</strong> ${phone || 'Not provided'}</p>
          <p><strong>Message:</strong></p>
          <p>${message}</p>
          <p><strong>Timestamp:</strong> ${new Date().toISOString()}</p>
        `
      });

      // Send confirmation email to user
      await sendEmail({
        to: email,
        subject: 'Thank you for contacting Alfanio Ltd',
        html: `
          <h2>Thank you for contacting Alfanio Ltd</h2>
          <p>Dear ${name},</p>
          <p>We have received your message and will get back to you shortly.</p>
          <p>Your message details:</p>
          <p>${message}</p>
          <br>
          <p>Best regards,</p>
          <p>Alfanio Ltd Team</p>
        `
      });

      logger.info('Contact form emails sent successfully', { name, email });

      res.json({ 
        success: true, 
        message: 'Message sent successfully! We will contact you soon.' 
      });
    } catch (error) {
      logger.error('Contact form error:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Failed to send message. Please try again.' 
      });
    }
  });

  app.post('/api/brochure', async (req, res) => {
    try {
      const { name, email, phone, message } = req.body;
      
      if (!name || !email) {
        return res.status(400).json({ 
          success: false, 
          message: 'Name and email are required' 
        });
      }

      logger.info('Processing brochure request', { name, email });

      // Send email to admin
      await sendEmail({
        to: process.env.EMAIL_TO,
        subject: `New Brochure Request from ${name}`,
        html: `
          <h2>New Brochure Request</h2>
          <p><strong>Name:</strong> ${name}</p>
          <p><strong>Email:</strong> ${email}</p>
          <p><strong>Phone:</strong> ${phone || 'Not provided'}</p>
          ${message ? `<p><strong>Message:</strong></p><p>${message}</p>` : ''}
          <p><strong>Timestamp:</strong> ${new Date().toISOString()}</p>
        `
      });

      // Send brochure to user
      await sendEmail({
        to: email,
        subject: 'Alfanio Ltd - Your Requested Brochure',
        html: `
          <h2>Thank you for your interest in Alfanio Ltd</h2>
          <p>Dear ${name},</p>
          <p>Thank you for requesting our brochure. Please find it attached.</p>
          <p>If you have any questions, feel free to contact us.</p>
          <br>
          <p>Best regards,</p>
          <p>Alfanio Ltd Team</p>
        `,
        attachments: [
          {
            filename: 'Alfanio-Brochure.pdf',
            path: join(rootDir, 'public', 'brochure.pdf')
          }
        ]
      });

      logger.info('Brochure request emails sent successfully', { name, email });

      res.json({ 
        success: true, 
        message: 'Brochure request received successfully. Check your email!' 
      });
    } catch (error) {
      logger.error('Brochure request error:', error);
      res.status(500).json({ 
        success: false, 
        message: 'Failed to process brochure request. Please try again.' 
      });
    }
  });

  // Health check endpoint
  app.get('/api/health', (req, res) => {
    const status = {
      status: 'healthy',
      timestamp: new Date().toISOString(),
      mongodb: mongoose.connection.readyState === 1 ? 'connected' : 'disconnected',
      email: transporterPool.some(t => t.isIdle()) ? 'ready' : 'busy'
    };
    
    logger.info('Health check', status);
    res.json(status);
  });

  // Fallback route handler for SPA
  app.get('*', (req, res) => {
    if (isProduction) {
      res.sendFile(join(rootDir, 'dist', 'index.html'));
    } else {
      res.status(404).send('Not found in development mode');
    }
  });

  // Start server
  app.listen(PORT, () => {
    logger.info(`${isProduction ? 'Production' : 'Development'} server running at http://localhost:${PORT}`);
  });

  // Graceful shutdown
  process.on('SIGTERM', () => {
    logger.info('SIGTERM received. Shutting down gracefully...');
    transporterPool.forEach(t => t.close());
    mongoose.connection.close();
    process.exit(0);
  });
}

startServer().catch(error => {
  logger.error('Server startup error:', error);
  process.exit(1);
});